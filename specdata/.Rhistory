tech.corr
rownames(tech.corr) <- c("IBM", "MSFT", "GOOG")
colnames(tech.corr) <- c("IBM", "MSFT", "GOOG")
print(tech.corr)
print(tech.corr["IBM","GOOG"]
print(tech.corr["IBM","GOOG"])
vec2 <- tech.corr[,3]
v1 <- 1:6
v2 <- seq(from=1, to=1.5, by=0.1)
v3 <- 21:27
v3 <- 21:26
f1 <- factor(v1)
f2 <- factor(v2)
f3 <- factor(v3)
dfrm <- data.frame(v1,v2,v3,f1,f2,f3)
unique.vector <- c(v1,v2,v3,f1,f2,f3)
dfrm1 <- data.frame(v1,v2,v3,f1,f2,f3)
dfrm2 <- as.data.frame(unique.vector)
dfrm1
dfrm2
dfrm2 <- as.data.frame(list(unique.vector)
dfrm2
dfrm2 <- as.data.frame(list(unique.vector))
dfrm2
unique.vector <- list(c(v1,v2,v3,f1,f2,f3))
dfrm2 <- as.data.frame(unique.vector)
print(dfrm2)
unique.vector
unique.list <- list(v1,v2,v3,f1,f2,f3)
dfrm2 <- as.data.frame(unique.list)
print(dfrm2)
unique.list
dfrm2 <- as.data.frame(unique.list)
print(dfrm2)
unique.list <- list(v1,v2,v3,f1,f2,f3)
unique.list
?rep
f1 <- rep(am, 6)
source('~/.active-rstudio-document', echo=TRUE)
f1 <- rep("am", 6)
f1
f1 <- factor(rep("am", 6))
f1
f2 <- factor(rep("bam", 6))
f3 <- factor(rep("sbam", 6))
unique.list <- list(v1,v2,v3,f1,f2,f3)
dfrm2 <- as.data.frame(unique.list) #i
print(dfrm2)  # fucked up, non capisco
v1 <- 1:6
unique.list <- list(v1,v2,v3,f1,f2,f3)
dfrm2 <- as.data.frame(unique.list) #if starting from a list of elements
print(dfrm2)  # fucked up, non capisco
unique.list
dfrm2
unique.list <- list(v1,v2,v3,f1,f2,f3)
unique.list
unique.list <- list(v1,v2,v3,f1)
dfrm2 <- as.data.frame(unique.list) #if starting from a list of elements
print(dfrm2)  # fucked up, non capisco
unique.list <- list(v1,v3,f1)
dfrm2 <- as.data.frame(unique.list) #if starting from a list of elements
print(dfrm2)  # fucked up, non capisco
unique.list <- list(v1, v2, v3)
dfrm2 <- as.data.frame(unique.list)
print(dfrm2)  # fucked up, non capisco
unique.list <- list(v1=v1, v2=v2, v3=v3, f1=f1, f2=f2, f3=f3)
dfrm2 <- as.data.frame(unique.list) #if starting from a list of elements
print(dfrm2)  # fucked up, non capisco
?do.call
obs1 <- data.frame(pred1=1,pred2=2, pred3=3, resp=4)
obs2 <- data.frame(pred1=5,pred2=6, pred3=7, resp=8)
lst <- list(obs1, obs2)
lst
rbind(obs[[1]], obs[[2]])
rbind(lst[[1]], lst[[2]])
do.call(rbind, lst)
dfrm <- data.frame(dosage=numeric(N), response=character(N), lab=factor(N, levels=c("south", "north", "east")))
N <- 1000
dfrm <- data.frame(dosage=numeric(N), response=character(N), lab=factor(N, levels=c("south", "north", "east")))
x <- factor(c("yes", "no", "yes","yes","no","yes"))
table(x)
m <- matrix(1:4, nrow=2, ncol=2)
dimnames(m) <- list(c("a","b"), c("c","d"))
m
require(MASS)
install.packages("MASS")
install.packages("MASS")
require(MASS)
subset(Cars93, select=Model, subset=(MPG.city > 30)) # select all the car models exceding 30 miles per gallon
subset(Cars93, select=c(Model, Min.Price,Max.Price), subset=(Cylinders==4 & Origin =="USA")) # select the model and price range only for cars with 4 cylinders and from the USA
subset(Cars93, select=Model, subset=c(MPG.city > median(MPG.city)))
subset(Cars93, select=c(Model, MPG.city), subset=c(MPG.city > median(MPG.city)))
subset(Cars93, select=c(Model, MPG.city, median(MPG.city)), subset=c(MPG.city > median(MPG.city)))
edit(Cars93)
install.packages("XQuartz")
edit(suburbs)
attributes(Cars93)
edit(Cars93)
require(Cars93)
edit(Cars93)
temp <- edit(Cars93)
v1 <- 1:6
v2 <- seq(from=1, to=1.5, by=0.1)
v3 <- 21:26
f1 <- factor(v1)
f2 <- factor(v2)
f3 <- factor(v3)
dfrm1 <- data.frame(v1,v2,v3,f1,f2,f3)
edit(dfrm1)
install.packages("XQuartz")
require(MASS)
edit(Cars93)
v1 <- 1:6
v2 <- seq(from=1, to=1.5, by=0.1)
v3 <- 21:26
f1 <- factor(v1)
f2 <- factor(v2)
f3 <- factor(v3)
dfrm1 <- data.frame(v1,v2,v3,f1,f2,f3)
edit(dfrm1)
locale
LC_CTYPE=C R
"LC_CTYPE=C R"
edit(dfrm1)
capabilities("X11")
edit(dfrm1)
v1 <- 1:6
v2 <- seq(from=1, to=1.5, by=0.1)
v3 <- 21:26
f1 <- factor(v1)
f2 <- factor(v2)
f3 <- factor(v3)
dfrm1 <- data.frame(v1,v2,v3,f1,f2,f3)
edit(dfrm1)
getwd()
library(MASS)
g <- split(Cars$MPG.city, Cars$Origin)
g <- split(Cars93$MPG.city, Cars93$Origin)
print(g)
median(g[[1]])
median(g[[2]])
median(g[1])
g <- unstack(data.frame(MPG.city, Origin))
g <- unstack(Cars93(MPG.city, Origin))
g <- unstack(data.frame(Cars93$MPG.city, Cars93$Origin))
g
g <- unstack(Cars93)
S1 <- floor(runif(20, min=68, max=98))
S2 <- floor(runif(20, min=60, max=100))
S3 <- floor(runif(20, min=75, max=99))
S4 <- floor(runif(20, min=63, max=99))
ls <- list(S1,S2,S3,S4,)
ls <- list(S1,S2,S3,S4)
ls
lapply(scores, length)
scores <- list(S1,S2,S3,S4)
rm(ls)
lapply(scores, length)
capply(scores, length)
sapply(scores, length)
sapply(scores, mean)
sapply(scores, sd)
sapply(scores, range)
tests <- lapply(scores, t.test)
tests
sapply(tests, function(t), t$conf.int)
sapply(tests, function(t) t$conf.int)
scores <- list(S1=S1,S2=S2,S3=S3,S4=S4)
tests <- lapply(scores, t.test)
sapply(tests, function(t) t$conf.int)
search(suburbs)
search("suburbs")
library(suburbs)
require(suburbs)
search()
installed.packages()
attach(suburbs)
?%%
gcd <- function(a,b) {
if (b==0) return(a)
else return(gcd(b, a%%b))
} # algorithm to obtain the minimum commune denominator between the vector a and b
gcd(c(1,2,3), c(9,6,3))
mapply(gcd, c(1,2,3), c(9,6,3))
x <- 2
y <- if(x>3) {
10
} else {
0
}
x <- 4
y <- if(x>3) {
10
} else {
0
}
for(i in 1:10){
print(i)
}
x <- c("a", "b", "c", "d")
for(i in 1:4){
print[x(i)]
}
x <- c("a", "b", "c", "d")
for(i in 1:4){
print(x[i])
}
for(i in seq_along(x)){
print(x[i])
}
for(i in 1:4) print(x[i])
seq_len(x)
x <- mat(1:6, 2, 3)
x <- matrix(1:6, 2, 3)
x <- matrix(1:6, 2, 3)
for(i in seq_len(nrow(x))) {
for(j in seq_len(ncol(x))) {
print(x[i, j])
}
}
z <- 5
while(z >= 3 && 10) {
print(z)
coin <- rbinom(1, 1, 0.5) # where in rbinom(number of experiments, number of repetitions, probability of success)
if(coin==1) {
z <- z+1
} else {
z <- z - 1
}
}
z <- 5
while(z >= 3 && 10) {
print(z)
coin <- rbinom(1, 1, 0.5) # where in rbinom(number of experiments, number of repetitions, probability of success)
if(coin==1) {
z <- z+1
} else {
z <- z - 1
}
}
z <- 5
while(z >= 3 && 10) {
print(z)
coin <- rbinom(1, 1, 0.5) # where in rbinom(number of experiments, number of repetitions, probability of success)
if(coin==1) {
z <- z+1
} else {
z <- z - 1
}
}
z <- 5
while(z >= 3 && 10) {
print(z)
coin <- rbinom(1, 1, 0.5) # where in rbinom(number of experiments, number of repetitions, probability of success)
if(coin==1) {
z <- z+1
} else {
z <- z - 1
}
}
z <- 5
while(z >= 3 && 10) {
print(z)
coin <- rbinom(1, 1, 0.5) # where in rbinom(number of experiments, number of repetitions, probability of success)
if(coin==1) {
z <- z+1
} else {
z <- z - 1
}
}
z <- 5
while(z >= 3 && 10) {
print(z)
coin <- rbinom(1, 1, 0.5) # where in rbinom(number of experiments, number of repetitions, probability of success)
if(coin==1) {
z <- z+1
} else {
z <- z - 1
}
}
z <- 5
while(z >= 3 && 10) {
print(z)
coin <- rbinom(1, 1, 0.5) # where in rbinom(number of experiments, number of repetitions, probability of success)
if(coin==1) {
z <- z+1
} else {
z <- z - 1
}
}
z <- 5
while(z >= 3 && 10) {
print(z)
coin <- rbinom(1, 1, 0.5) # where in rbinom(number of experiments, number of repetitions, probability of success)
if(coin==1) {
z <- z+1
} else {
z <- z - 1
}
}
z <- 5
while(z >= 3 && 10) {
print(z)
coin <- rbinom(1, 1, 0.5) # where in rbinom(number of experiments, number of repetitions, probability of success)
if(coin==1) {
z <- z+1
} else {
z <- z - 1
}
}
z <- 5
while(z >= 3 && <= 10) {
print(z)
coin <- rbinom(1, 1, 0.5) # where in rbinom(number of experiments, number of repetitions, probability of success)
if(coin==1) {
z <- z+1
} else {
z <- z - 1
}
}
z <- 5
while(z >= 3 && <= 10) {
print(z)
coin <- rbinom(1, 1, 0.5) # where in rbinom(number of experiments, number of repetitions, probability of success)
if(coin==1) {
z <- z+1
} else {
z <- z - 1
}
}
z <- 5
while(z >= 3 && z <= 10) {
print(z)
coin <- rbinom(1, 1, 0.5) # where in rbinom(number of experiments, number of repetitions, probability of success)
if(coin==1) {
z <- z+1
} else {
z <- z - 1
}
}
z <- 5
while(z >= 3 && z <= 10) {
print(z)
coin <- rbinom(1, 1, 0.5) # where in rbinom(number of experiments, number of repetitions, probability of success)
if(coin==1) {
z <- z+1
} else {
z <- z - 1
}
}
z <- 5
while(z >= 3 && z <= 10) {
print(z)
coin <- rbinom(1, 1, 0.5) # where in rbinom(number of experiments, number of repetitions, probability of success)
if(coin==1) {
z <- z+1
} else {
z <- z - 1
}
}
add2 <- function(x,y) {
x+y
}
add2(2,5)
above function(x, n) {
use <- x>n
x[use]
}
above function(x, n) {
use <- x>n
x[use]
}
above function(x, n) {
use <- x>n
x[use]
}
above10 function(x) {
use <- x>10
x[use]
}
above10 function(x) {
use <- x>10
x[use]
}
above10 function(x) {
use <- x>10
x[use]
}
above10 function(x) {
use <- x > 10
x[use]
}
x <- 1:20
above10 <- function(x) {
use <- x > 10
x[use]
}
above10[x]
above10(x)
above <- function(x, n) {
use <- x>n
x[use]
}
n <- 12
above <- function(x, n) {
use <- x>n
x[use]
}
above(x, 12)
above <- function(x, n= 10) {
use <- x>n
x[use]
}
above(x)
above(x, 12)
matrix(1:12, 3, 3)
mat <- matrix(1:12, 3, 3)
ncol(mat)
numeric(ncol(mat))
mat <- matrix(1:12, 3, 3)
columnmean(mat)
columnmean <- function(y){ # where y is a matrix or a dataframe
nc <- ncol(y) # count the number of columns
means <- numeric(nc) # create a vector with as much 0 as the value of nc
for(i in 1:nc) {  # further loop
means[i] <- mean(y[,i]) # overwrite the vector values with the mean of the matrix
}
means
}
mat <- matrix(1:12, 3, 3)
columnmean(mat)
mat
mat <- cbind(mat, c(NA, NA, NA))
mat
columnmean(mat)
columnmean <- function(y, removeNA=TRUE){ # where y is a matrix or a dataframe
nc <- ncol(y) # count the number of columns
means <- numeric(nc) # create a vector with as much 0 as the value of nc
for(i in 1:nc) {  # further loop
means[i] <- mean(y[,i], na.rm=removeNA) # overwrite the vector values with the mean of the matrix
}
means
}
columnmean(mat)
columnmean <- function(y, removeNA = TRUE){ # where y is a matrix or a dataframe
nc <- ncol(y) # count the number of columns
means <- numeric(nc) # create a vector with as much 0 as the value of nc
for(i in 1:nc) {  # further loop
means[i] <- mean(y[,i], na.rm = removeNA) # overwrite the vector values with the mean of the matrix
}
means
}
mat <- matrix(1:12, 3, 3)
mat <- cbind(mat, c(NA, NA, NA))
columnmean(mat)
columnmean <- function(y, removeNA = TRUE){ # where y is a matrix or a dataframe
nc <- ncol(y) # count the number of columns
means <- numeric(nc) # create a vector with as much 0 as the value of nc
for(i in 1:nc) {  # further loop
means[i] <- mean(y[,i], na.rm = TRUE) # overwrite the vector values with the mean of the matrix
}
means
}
mat <- matrix(1:12, 3, 3)
mat <- cbind(mat, c(NA, NA, NA))
columnmean(mat)
clas(mat)
class(mat)
attributes(mat)
class(mat[,4])
class(mat[,3])
columnmean <- function(y, removeNA = TRUE){ # where y is a matrix or a dataframe
nc <- ncol(y) # count the number of columns
means <- numeric(nc) # create a vector with as much 0 as the value of nc
for(i in 1:nc) {  # further loop
means[i] <- mean(y[,i], na.rm = removeNA) # overwrite the vector values with the mean of the matrix
}
means
}
mat <- matrix(1:12, 3, 3)
mat <- cbind(mat, c(NA, NA, NA))
columnmean(mat)
means
columnmean(mat)
mat <- matrix(1:12, 3, 3)
mat <- cbind(mat, c(NA, 3, NA))
columnmean(mat)
columnmean(mat, FALSE)
pollutantmean <- function(directory, pollutant, id ){
wd <- "/Users/newaesthetic/data/R/coursera/programming_with_R/ass1"
setwd(paste(wd, directory, sep="/"))
n <- as.numeric(max(id)-min(id))
vmean <- numeric(n+1)
lmean <- numeric(n+1)
install.packages("stringi")
library(stringi)
for (i in id) {
ni <- stri_pad(i, 3, pad = "0")
dfrm <- read.csv(paste(ni,".csv", sep=""))
l <- i-(min(id)-1)
x <- dfrm[pollutant]
reallength <- length(x[[1]])-sum(is.na(x[[1]]))
vmean[l] <- mean(x[[1]], na.rm = TRUE)*reallength
lmean[l] <- reallength
}
return(sum(vmean)/sum(lmean))
}
pollutantmean("specdata", "sulfate", 1:10)
sprintf("name_%03d", 1)
sprintf("%03d", 1)
sprintf("%03d", 18)
sprintf("%03d", 181)
